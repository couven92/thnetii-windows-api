using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;

using THNETII.InteropServices.Memory;

using static THNETII.WinApi.Native.WinNT.EXCEPTION_CODE;
using static THNETII.WinApi.Native.WinNT.EXCEPTION_FLAGS;

namespace THNETII.WinApi.Native.WinNT
{
    // C:\Program Files (x86)\Windows Kits\10\Include\10.0.17134.0\um\winnt.h, line 8762
    /// <summary>
    /// Describes an exception.
    /// </summary>
    /// <remarks>
    /// <para>Microsoft Docs page: <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-_exception_record">EXCEPTION_RECORD structure</a></para>
    /// </remarks>
    /// <seealso cref="EXCEPTION_DEBUG_INFO"/>
    /// <seealso cref="EXCEPTION_POINTERS"/>
    /// <seealso cref="GetExceptionInformation"/>
    /// <seealso cref="RaiseException"/>
    /// <seealso cref="UnhandledExceptionFilter"/>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct EXCEPTION_RECORD
    {
        /// <summary>
        /// The reason the exception occurred. This is the code generated by a hardware exception, or the code specified in the <see cref="RaiseException"/> function for a software-generated exception.
        /// </summary>
        [MarshalAs(UnmanagedType.I4)]
        public EXCEPTION_CODE ExceptionCode;
        /// <summary>
        /// The exception flags. This member can be either zero, indicating a continuable exception, or <see cref="EXCEPTION_NONCONTINUABLE"/> indicating a noncontinuable exception. Any attempt to continue execution after a noncontinuable exception causes the <see cref="EXCEPTION_NONCONTINUABLE_EXCEPTION"/> exception.
        /// </summary>
        [MarshalAs(UnmanagedType.I4)]
        public EXCEPTION_FLAGS ExceptionFlags;
        /// <summary>
        /// A pointer to an associated <see cref="EXCEPTION_RECORD"/> structure. Exception records can be chained together to provide additional information when nested exceptions occur.
        /// </summary>
        public EXCEPTION_RECORD* ExceptionRecord;
        /// <summary>
        /// The address where the exception occurred.
        /// </summary>
        public IntPtr ExceptionAddress;
        /// <summary>
        /// The number of parameters associated with the exception. This is the number of defined elements in the <see cref="ExceptionInformation"/> array.
        /// </summary>
        public int NumberParameters;
        #region public UIntPtr ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
        internal ExceptionInformationField ExceptionInformationValue;
        [StructLayout(LayoutKind.Sequential)]
        internal struct ExceptionInformationField
        {
            public const int Length = WinNTConstants.EXCEPTION_MAXIMUM_PARAMETERS;
            public ref UIntPtr this[int index] => ref Span[index];
            public Span<UIntPtr> Span => MemoryMarshal.Cast<ExceptionInformationField, UIntPtr>(SpanOverRef.GetSpan(ref this));
#pragma warning disable IDE0044 // Add readonly modifier
            private UIntPtr p0;
            private UIntPtr p1;
            private UIntPtr p2;
            private UIntPtr p3;
            private UIntPtr p4;
            private UIntPtr p5;
            private UIntPtr p6;
            private UIntPtr p7;
            private UIntPtr p8;
            private UIntPtr p9;
            private UIntPtr p10;
            private UIntPtr p11;
            private UIntPtr p12;
            private UIntPtr p13;
            private UIntPtr p14;
#pragma warning restore IDE0044 // Add readonly modifier
        }

        /// <summary>
        /// A span of additional arguments that describe the exception. The RaiseException function can specify this array of arguments. For most exception codes, the array elements are undefined.
        /// </summary>
        /// <remarks>
        /// The following table describes the exception codes whose array elements are defined.
        /// <list type="table">
        /// <listheader><term>Exception code</term><description>Meaning</description></listheader>
        /// <item>
        /// <term><see cref="EXCEPTION_ACCESS_VIOLATION"/></term>
        /// <description>
        /// <para>The first element of the array contains a read-write flag that indicates the type of operation that caused the access violation. If this value is zero, the thread attempted to read the inaccessible data. If this value is 1, the thread attempted to write to an inaccessible address.<br/>If this value is 8, the thread causes a user-mode data execution prevention (DEP) violation.</para>
        /// <para>The second array element specifies the virtual address of the inaccessible data.</para>
        /// </description>
        /// </item>
        /// <item>
        /// <term><see cref="EXCEPTION_IN_PAGE_ERROR"/></term>
        /// <description>
        /// <para>The first element of the array contains a read-write flag that indicates the type of operation that caused the access violation. If this value is zero, the thread attempted to read the inaccessible data. If this value is 1, the thread attempted to write to an inaccessible address.<br/>If this value is 8, the thread causes a user-mode data execution prevention (DEP) violation.</para>
        /// <para>The second array element specifies the virtual address of the inaccessible data.</para>
        /// <para>The third array element specifies the underlying <see cref="NTSTATUS"/> code that resulted in the exception.</para>
        /// </description>
        /// </item>
        /// </list>
        /// </remarks>
        [SuppressMessage("Usage", "PC001: API not supported on all platforms", Justification = "https://github.com/dotnet/platform-compat/issues/123")]
        public Span<UIntPtr> ExceptionInformation
        {
            get
            {
                if (NumberParameters < 0 || NumberParameters > ExceptionInformationField.Length)
                    return ExceptionInformationValue.Span;
                return ExceptionInformationValue.Span.Slice(NumberParameters);
            }
        }
        #endregion
    }
}
